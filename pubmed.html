<!DOCTYPE html>
<!--suppress ALL -->
<html lang="en" xmlns:v-on="http://www.w3.org/1999/xhtml" xmlns:v-bind="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <title>PubMed</title>
    <link rel="icon" href="/static/favicon.png" type="image/x-png">
    <link rel="stylesheet" href="/static/spectre.min.css" type="text/css">
    <link rel="stylesheet" href="/static/spectre-icons.min.css" type="text/css">
    <link rel="stylesheet" href="/static/spectre-exp.min.css" type="text/css">
    <link rel="stylesheet" href="/static/vis.min.css" type="text/css">
    <link rel="stylesheet" href="/static/vue-multiselect.min.css" type="text/css">
    <link rel="stylesheet" href="/static/logtail.css" type="text/css">
    <link rel="stylesheet" href="/static/searchrefiner.css" type="text/css">
    <style>
        .text-sm {
            line-height: 0.9rem;
        }

        .span-sm,
        .a-sm {
            font-size: 10px;
            line-height: 0.0rem;
        }

        .author-sm {
            line-height: 0.0rem;
            font-size: 12px;
            margin: 0 0 0 0;
            padding: 0;
            text-align: left;
        }

        .author-sm:after {
            content: ",";
            margin-right: 6px;
        }

        .a-sm:after {
            content: ';';
            margin-right: 6px;
        }

        .author-sm:last-child:after,
        .a-sm:last-child:after {
            content: none;
        }

        /* Thanks to https://cn.vuejs.org/v2/examples/modal.html */
        .modal-mask {
            overflow: auto;
            position: fixed;
            z-index: 9998;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, .5);
            opacity: 1;
            display: table;
            transition: opacity .3s ease;
        }

        .modal-wrapper {
            overflow: auto;
            display: table-cell;
            vertical-align: middle;
        }

        .modal-container {
            max-width: 100%;
            overflow: auto;
            margin: 0px auto;
            padding: 20px 30px;
            background-color: #fff;
            opacity: 1;
            border-radius: 2px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, .33);
            transition: all .3s ease;
            font-family: Helvetica, Arial, sans-serif;
        }

        .modal-body {
            overflow: auto;
            margin: 20px 0;
        }

        .modal-default-button {
            line-height: 12px;
            width: 8%;
            font-size: 12pt;
            font-family: tahoma;
            margin-top: 1px;
            margin-right: 2px;
            position: relative;
            top:0;
            right:0;
            float: right;
        }

        .modal-enter {
            opacity: 0.8;
        }

        .modal-leave-active {
            opacity: 0.3;
        }

        .modal-enter .modal-container,
        .modal-leave-active .modal-container {
            -webkit-transform: scale(0.1);
            transform: scale(0.1);
        }
    </style>
</head>
<body>
<script type="text/javascript" src="/static/bigbro.js"></script>
<script type="text/javascript">
    let bb = BigBro.init({{.UID}}, window.location.host + "/plugin/iuserstudy?bigbro");
    window.addEventListener("load", function (e) {
        bb.log(e, "pageload", "{{.UID}}")
    })
</script>
<div class="container" id="app">
    <header class="navbar bg-secondary nav-height">
        <section class="navbar-section"><a href="?uid={{.UID}}"><i class="icon icon-arrow-left"></i>back</a></section>
        <section class="navbar-section">Participant ID:<span class="label label-primary mr-1 ml-1">{{.UID}}</span></section>
    </header>
    <div class="columns">
        <div class="column col-1"></div>
        <div class="column col-10">
            <div class="form-group">
                <pre name="query" class="code" id="search-box">[[ textQuery ]]</pre>
                <input type="hidden" name="lang" value="pubmed">
            </div>
            {{/*<a href="#">Edit</a>*/}}
            <div class="panel p-2">
                <div class="panel-header">
                    <b>Query Builder</b>
                </div>
                <div class="panel-body">
                    <builder v-for="(query, index) in queries"
                             :key="query.id"
                             v-on:add="addQuery"
                             v-on:remove="removeQuery"
                             v-bind:query="query"
                             v-bind:index="index"
                             v-bind:last="index==queries.length-1"></builder>
                    <a href="#" v-on:click="clear">Clear</a>
                </div>
                <div class="panel-footer">
                    <button class="btn btn-primary" id="btn-update-tree" v-on:click="loadResults">
                        <i class="icon icon-forward"></i> Results
                    </button>
                    <div class="divider"></div>
                    <p>Use the query builder above to formulate your query. Click the back link in the top left corner of the interface to return to the study.</p>
                </div>
            </div>
            <div class="panel p-2 mt-2">
                <div class="panel-header">
                    <ul class="tab tab-block">
                        <li class="tab-item" v-bind:class="{active: tabState==='results'}" v-on:click="tabState='results'">
                            <a href="#" class="badge" v-bind:data-badge="total">Results</a>
                        </li>
                        <li class="tab-item" v-bind:class="{active: tabState==='history'}" v-on:click="tabState='history'">
                            <a href="#">History</a>
                        </li>
                        <li class="tab-item" v-bind:class="{active: tabState==='seed'}" v-on:click="tabState='seed'">
                            <a href="#">Seed Documents</a>
                        </li>
                        <li class="tab-item" v-bind:class="{active: tabState==='criteria'}" v-on:click="tabState='criteria'">
                            <a href="#">Search Criteria</a>
                        </li>
                        <li class="tab-item" v-bind:class="{active: tabState==='mesh'}" v-on:click="tabState='mesh';meshSearchBoxFocus()">
                            <a href="#" class="badge" v-bind:data-badge="ids.length">MeSH Browser</a>
                        </li>
                    </ul>
                </div>
                <div class="panel-body container" v-if="tabState==='history'">
                    <div class="columns">
                        <div class="column col-8 text-italic">Query</div>
                        <div class="column col-2 text-italic">Items found</div>
                    </div>
                    <div class="divider"></div>
                    <div v-for="query in history">
                        <div class="columns">
                            <div class="column col-8">[[ query.QueryString ]]</div>
                            <div class="column col-2">[[ query.NumRet ]]</div>
                        </div>
                        <div class="divider"></div>
                    </div>
                </div>
                <div class="panel-body container" v-show="tabState==='results'" style="overflow:hidden;">
                    <div v-if="busy && !ready" class="loading loading-lg"></div>
                    <p v-if="!init">Results will show here once you click the Results button above.</p>
                    <ol v-infinite-scroll="loadNextResults" infinite-scroll-disabled="busy" infinite-scroll-distance="10">
                        <li v-for="c in results" class="pb-2">
                            <a href="#/" v-on:click="loadResultDocument(c.PMID)">[[c.TI]]</a>
                            <!-- Thanks to https://cn.vuejs.org/v2/examples/modal.html-->
                            <modal v-if="showModal" v-on:close="showModal = false">
                                <h3 slot="header">[[ document.title ]]</h3>
                                <h5 slot="header" v-show="!document.title">[No Title] [[document.pmid]]</h5>
                                <span slot="header" class="span-sm"><strong>PMID</strong>: [[ document.pmid ]]</span>
                                <br slot="header">
                                <span slot="header" class="span-sm" v-if="document.type == 'book'"><strong>Book</strong>: [[ document.book ]]</span>
                                <span slot="header" class="span-sm" v-if="document.type == 'article'"><strong>Journal</strong>: [[ document.journal ]]</span>
                                <br slot="header">
                                <span slot="header" class="span-sm"><strong>Publication Date</strong>: [[ document.pubdate ]]</span>
                                <div slot="body" class="divider"></div>
                                <h5 slot="body"><strong>Abstract:</strong></h5>
                                <ul style="list-style-type: none;" slot="body">
                                    <li class="span-rg" v-for="field in document.abstract">
                                        <span class="span-rg" v-if="field.field != ''"><strong>[[ field.field ]]</strong>: [[ field.content ]]</span>
                                        <span class="span-rg" v-if="field.field == ''">[[ field.content ]]</span>
                                    </li>
                                </ul>
                                <h5 slot="body" v-if="(document.type == 'book' || document.keywords != undefined)"><strong>Keywords:</strong></h5>
                                <h5 slot="body" v-if="document.type == 'article' && document.meshheadings != undefined && document.meshheadings[0] != undefined"><strong>Mesh Headings:</strong></h5>
                                <ul style="list-style-type: circle;" slot="body" v-if="document.type == 'book' || document.keywords != undefined">
                                    <li class="span-rg" v-for="keyword in document.keywords" v-if="document.keywords.length > 0">
                                        <span class="span-rg">[[ keyword ]]</span>
                                    </li>
                                </ul>
                                <ul style="list-style-type: circle;" slot="body" v-if="document.type == 'article' && document.meshheadings != undefined">
                                    <li class="span-rg" v-for="mesh in document.meshheadings" v-if="document.meshheadings.length > 0">
                                        <span class="span-rg">[[ mesh ]]</span>
                                    </li>
                                </ul>
                            </modal>
                            <a href="#/" v-on:click="loadResultDocument(c.PMID)" v-show="!c.TI">[No Title] [[c.PMID]]</a>
                            <div class="text-left text-sm">
                                <!-- <a v-for="author in c.AU" class="text-success author-sm"
                                   v-bind:href="'https://www.ncbi.nlm.nih.gov/pubmed/?term=%22' + author + '%22[Author]'">[[author]]</a> -->
                                <span v-for="author in c.AU" class="text-success author-sm">[[author]]</span>&nbsp;
                            </div>
                            <div class="text-left text-sm text-gray">
                                <span class="span-sm"><strong>PMID</strong>: [[ c.PMID ]]</span>
                            </div>
                        </li>
                    </ol>
                    <div v-if="busy && ready" class="loading loading-lg"></div>
                </div>
                <div class="panel-body container" v-show="tabState==='mesh'" style="overflow:hidden;">
                    <input class="panel-body" v-show="tabState==='mesh'" style="overflow:hidden;width:100%" v-model="meshTerm" id="meshInputBox" v-on:keyup="loadMeSH">
                    <div class="divider"></div>
                    <a href="#" v-on:click="resetMeSHBrowser()">Clear All</a>
                    <div class="panel-footer">
                        <button class="btn btn-primary" id="btn-update-tree" v-on:click="loadMeSH()">
                            <i class="icon icon-forward"></i> Search
                        </button>
                        <div class="divider"></div>
                        <p v-if="!meshInit">Use the search box above to input your term. Click the back link in the top left corner of the interface to return to the study.</p>
                        <div v-if="meshBusy && !meshReady" class="loading loading-lg"></div>
                        <div class="text-left text-sm text-gray">
                            <span class="span-sm" v-if="meshInit" style="font-size:100%"> Total of <strong>[[ ids.length ]]</strong> results found (<strong>[[ timeSpend ]]</strong> seconds)</span>
                        </div>
                        <ul style="list-style-type:none">
                            <li v-if="meshInit" v-for="info in displayedMeSHInfos" class="pb-2"> [[ info.rank ]].
                                <a href="#/" v-on:click="ctrlDiv(info.id)"> [[ info.name ]] </a></br>
                                <div class="text-left text-sm">
                                    <span><strong>Description:</strong> [[ info.desc ]] </span>
                                    <span v-show="info.desc === ''"> No description</span>
                                </div>
                                <div class="text-left text-sm text-gray">
                                    <span class="span-sm" v-show="info.yIntroduced != ''"><strong>Year Introduced:</strong> [[ info.yIntroduced ]]</span>
                                    <span class="span-sm" v-show="info.supDate != '1/01/01' && info.yIntroduced === ''"><strong>Year Introduced:</strong> [[ info.supDate ]]</span>
                                    <span class="span-sm" v-show="info.yIntroduced === '' && info.supDate === '1/01/01'"><strong>Year Introduced:</strong> Not Provided </span>
                                </div>
                                <ul style="display:none" v-bind:id="info.id" class="infoBox">
                                    <li v-for="term in info.terms">
                                        [[ term ]]
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <!--Thanks to https://vuejsexamples.com/pagination-in-vuejs-simple-way/-->
                        <ul class="pagination" v-if="meshInit">
                            <li class="page-item">
                                <button v-if="ids.length != 0" type="button" class="btn btn-primary" v-on:click="resetDiv('p')"> Previous </button>
                            </li>
                            <li class="page-item">
                                <button type="button" v-if="page <= totalPages" class="btn btn-primary"> <input v-bind:value="page" style="width:30%;height:100%;text-align:center" v-model="uDefPage" v-on:keyup="jumpPage" /> / [[ totalPages ]] </button>
                            </li>
                            <li class="page-item">
                                <button v-if="ids.length != 0" type="button" v-on:click="resetDiv('n')" class="btn btn-primary"> Next </button>
                            </li>
                        </ul>
                        <div v-if="meshInit && totalPages > 0">
                            Number of MeSH Terms Per Page:
                            <input type="number" class="panel-body" v-show="tabState==='mesh'" style="overflow:hidden;width:5%" v-model="userDefPerPage" v-on:keyup="changeNumOfTermsPerPage">
                            <button class="btn btn-primary" id="btn-update-tree" v-on:click="changeNumOfTermsPerPage()">
                                Change
                            </button>
                        </div>
                    </div>
                </div>
                <div class="panel-body container" v-if="tabState==='seed'" v-show="tabState==='seed'" style="overflow:hidden;">
                    <ol>
                        <li v-for="seed in seedDocInfos" class="pb-2">
                            <a href="#/" v-on:click="loadResultDocument(seed.pmid)">[[ seed.title ]]</a>
                            <modal v-if="showModal" v-on:close="showModal = false">
                                <h3 slot="header">[[ document.title ]]</h3>
                                <h5 slot="header" v-show="!document.title">[No Title] [[document.pmid]]</h5>
                                <span slot="header" class="span-sm"><strong>PMID</strong>: [[ document.pmid ]]</span>
                                <br slot="header">
                                <span slot="header" class="span-sm" v-if="document.type == 'book'"><strong>Book</strong>: [[ document.book ]]</span>
                                <span slot="header" class="span-sm" v-if="document.type == 'article'"><strong>Journal</strong>: [[ document.journal ]]</span>
                                <br slot="header">
                                <span slot="header" class="span-sm"><strong>Publication Date</strong>: [[ document.pubdate ]]</span>
                                <div slot="body" class="divider"></div>
                                <h5 slot="body"><strong>Abstract:</strong></h5>
                                <ul style="list-style-type: none;" slot="body">
                                    <li class="span-rg" v-for="field in document.abstract">
                                        <span class="span-rg" v-if="field.field != ''"><strong>[[ field.field ]]</strong>: [[ field.content ]]</span>
                                        <span class="span-rg" v-if="field.field == ''">[[ field.content ]]</span>
                                    </li>
                                </ul>
                                <h5 slot="body" v-if="document.type == 'book' || document.keywords.length > 0"><strong>Keywords:</strong></h5>
                                <h5 slot="body" v-if="document.type == 'article' && document.meshheadings != undefined && document.meshheadings.length > 0"><strong>Mesh Headings:</strong></h5>
                                <ul style="list-style-type: circle;" slot="body" v-if="document.type == 'book' || document.keywords.length > 0">
                                    <li class="span-rg" v-for="keyword in document.keywords">
                                        <span class="span-rg">[[ keyword ]]</span>
                                    </li>
                                </ul>
                                <ul style="list-style-type: circle;" slot="body" v-if="document.type == 'article' && document.meshheadings != undefined && document.meshheadings.length > 0">
                                    <li class="span-rg" v-for="mesh in document.meshheadings">
                                        <span class="span-rg">[[ mesh ]]</span>
                                    </li>
                                </ul>
                            </modal>
                            <a href="#/" v-on:click="loadResultDocument(seed.pmid)" v-show="!seed.title">[No Title] [[seed.pmid]]</a>
                            <div class="text-left text-sm text-gray">
                                <span class="span-sm"><strong>PMID</strong>: [[ seed.pmid ]]</span>
                            </div>
                        </li>
                    </ol>
                </div>
                <div class="panel-body container" v-if="tabState==='criteria'">
                    {{if eq .Protocol 1}}
                        {{template "protocol1"}}
                    {{else}}
                        {{template "protocol2"}}
                    {{end}}
                </div>
            </div>
        </div>
        <div class="column col-1"></div>
    </div>
</div>

<script type="text/x-template" id="builder">
    <div class="columns">
        <div class="column col-2">
            <select class="form-select select-sm" v-if="index>0" v-model="query.operator" v-bind:field="query.operator" v-on:change="updateCQR">
                <option value="and">AND</option>
                <option value="or">OR</option>
                <option value="not">NOT</option>
            </select>
        </div>
        <div class="column col-3">
            <select class="form-select select-sm" v-model="query.field" v-bind:field="query.field" v-on:change="updateCQR">
                <option value="Affiliation">Affiliation</option>
                <option value="All Fields" selected="selected">All Fields</option>
                <option value="Author">Author</option>
                <option value="Author - Corporate">Author - Corporate</option>
                <option value="Author - First">Author - First</option>
                <option value="Author - Full">Author - Full</option>
                <option value="Author - Identifier">Author - Identifier</option>
                <option value="Author - Last">Author - Last</option>
                <option value="Book">Book</option>
                <option value="Conflict of Interest Statements">Conflict of Interest Statements</option>
                <option value="Date - Completion">Date - Completion</option>
                <option value="Date - Create">Date - Create</option>
                <option value="Date - Entrez">Date - Entrez</option>
                <option value="Date - MeSH">Date - MeSH</option>
                <option value="Date - Modification">Date - Modification</option>
                <option value="Date - Publication">Date - Publication</option>
                <option value="EC/RN Number">EC/RN Number</option>
                <option value="Editor">Editor</option>
                <option value="Filter">Filter</option>
                <option value="Grant Number">Grant Number</option>
                <option value="ISBN">ISBN</option>
                <option value="Investigator">Investigator</option>
                <option value="Investigator - Full">Investigator - Full</option>
                <option value="Issue">Issue</option>
                <option value="Journal">Journal</option>
                <option value="Language">Language</option>
                <option value="Location ID">Location ID</option>
                <option value="MeSH Major Topic">MeSH Major Topic</option>
                <option value="MeSH Subheading">MeSH Subheading</option>
                <option value="MeSH Terms">MeSH Terms</option>
                <option value="Other Term">Other Term</option>
                <option value="Pagination">Pagination</option>
                <option value="Pharmacological Action">Pharmacological Action</option>
                <option value="Publication Type">Publication Type</option>
                <option value="Publisher">Publisher</option>
                <option value="Secondary Source ID">Secondary Source ID</option>
                <option value="Subject - Personal Name">Subject - Personal Name</option>
                <option value="Supplementary Concept">Supplementary Concept</option>
                <option value="Text Word">Text Word</option>
                <option value="Title">Title</option>
                <option value="Title/Abstract">Title/Abstract</option>
                <option value="Transliterated Title">Transliterated Title</option>
                <option value="Volume">Volume</option>
            </select>
        </div>
        <div class="column col-5">
            <input type="text" v-model="query.query" v-bind:query="query.query" v-on:keyup="updateCQR" class="form-input input-sm"/>
        </div>
        <div class="column col-2">
            <div class="btn-group">
                <a href="#" class="btn btn-action btn-sm" v-on:click="removeSelf"><i class="icon icon-minus"></i></a>
                <a href="#" class="btn btn-action btn-sm" v-if="last" v-on:click="addQuery"><i class="icon icon-plus"></i></a>
            </div>
        </div>
    </div>
</script>
<!-- template for the modal component -->
<script type="text/x-template" id="modal-template">
    <transition name="modal">
        <div class="modal-mask">
            <div class="modal-wrapper">
                <div class="modal-container">
                    <a href="#/" class="modal-default-button" @click="$emit('close')">
                        Close
                    </a>
                    <div class="modal-header">
                        <slot name="header">
                            default header
                        </slot>
                    </div>
                    <div class="modal-body">
                        <slot name="body">
                            default body
                        </slot>
                    </div>
                </div>
            </div>
        </div>
    </transition>
</script>
<!-- Main app code. -->
<script src="/static/vue.js" type="text/javascript"></script>
<script src="/static/vue-infinite-scroll.js" type="text/javascript"></script>
<script type="text/javascript" src="/static/lodash.min.js"></script>
<script src="/static/Sortable.min.js"></script>
<script src="/static/vuedraggable.min.js"></script>
<script src="/static/xml2json.js"></script>
<!--suppress JSUnusedGlobalSymbols -->
<script>
    Vue.component('modal', {
        template: '#modal-template'
    })
    var structuredID = 0;
    Vue.component("builder", {
        delimiters: ["[[", "]]"],
        template: "#builder",
        props: ["index", "last", "query"],
        data: function () {
            return {
                id: structuredID++,
            }
        },
        beforeMount: function () {
            this.updateCQR();
        },
        methods: {
            removeSelf: function () {
                this.$emit("remove", this.$props.index);
            },
            addQuery: function () {
                this.$emit("add", {query: "", fields: ["All Fields"], operator: "and", cqr: {}, field: "All Fields"})
            },
            updateCQR: function () {
                if (this.$props.query.query.length === 0) {
                    this.$props.query.cqr = {query: "", fields: [this.$props.query.field]}
                    return
                }
                var self = this;
                var request = new XMLHttpRequest();
                request.addEventListener("load", function (ev) {
                    if (ev.currentTarget.status === 200) {
                        self.$props.query.cqr = JSON.parse(ev.currentTarget.responseText)
                        self.$props.query.cqr = fixNilFields(self.$props.query.cqr, self.$props.query.field)
                    }
                });
                request.open("POST", "/api/query2cqr");
                request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                request.send("query=" + self.query.query + "&lang=pubmed&field=" + self.query.field);
            }
        }
    });

    fixNilFields = function (query, field) {
        if (query.children !== undefined && query.children.length > 0) {
            for (var i = 0; i < query.children.length; i++) {
                query.children[i] = fixNilFields(query.children[i], field)
            }
        } else if (query.fields[0] === "nil") {
            query.fields[0] = field
        }
        return query
    }

    var vm = new Vue({
        delimiters: ["[[", "]]"],
        el: "#app",
        data: {
            results: [],
            total: 0,
            busy: false,
            ready: false,
            finished: false,
            init: false,
            start: 0,
            tabState: "results",
            date: "{{.Date}}",

            // handle MeSH browser
            ids: [],
            meshInfo: [{rank: 0, id:"", name:"", desc:"", yIntroduced:"", supDate:"", terms:[]}],
            meshTerm: "",
            meshInit: false,
            meshReady: false,
            meshBusy: false,

            // handle pagination
			page: 1,
			perPage: 5,
            totalPages: 0,
            userDefPerPage: 5,
            uDefPage: 1,

            // handle time spend count
            meshSearchStart: 0,
            meshSearchEnd: 0,
            timeSpend: 0,

            seed: "{{.Seed}}",
            seedDocIds: null,
            seedDocInfos: [{"pmid": null, "title" : null}],

            document: {"type" : null, "pmid": null, "title": null, "abstract": [], "pubdate": null, "journal": null, "book":null, "meshheadings" : [], "keywords" : []},

            showModal: false,

            numRet: 0,
            numRel: 0,
            numRelRet: 0,
            textQuery: "",
            textQueryDate: "",
            queryLanguage: "{{.Language}}",
            queries: [{query: "", field: "All Fields", operator: "", cqr: {}}, {query: "", field: "All Fields", operator: "and", cqr: {}}],
            history: [],
        },
        computed: {
            displayedMeSHInfos() {
			    return this.paginate(this.meshInfo);
		    },
            cqrQuery() {
                var q = {};
                for (var i = 0; i < this.queries.length; i++) {
                    var child = {}
                    if (!Object.keys(this.queries[i].cqr).length) {
                        child = {
                            query: this.queries[i].query,
                            fields: [this.queries[i].field],
                        }
                    } else {
                        child = this.queries[i].cqr;
                        if (child === undefined || child.operator == "") {
                            child = {
                                query: this.queries[i].query,
                                fields: [this.queries[i].field],
                            }
                        }
                    }

                    // Skip adding this child because it is empty.
                    if (child.operator === undefined && (child.query === null || child.query === undefined || child.query.length === 0)) {
                        continue
                    }

                    // Add the child underneath the current query.
                    if (!Object.keys(q).length) {
                        q = child
                    } else {
                        q = {
                            operator: this.queries[i].operator,
                            children: [
                                child,
                                q
                            ]
                        }
                    }
                }
                return JSON.stringify(q)
            }
        },
        methods: {
            meshSearchBoxFocus: function() {
                document.getElementById("meshInputBox").focus();
            },
            jumpPage: function (e) {
                if (e.keyCode === 13) {
                    if (this.uDefPage != this.page && this.uDefPage != '' && this.uDefPage != undefined && this.uDefPage > 0 && this.uDefPage <= this.totalPages) {
                        this.page = this.uDefPage;
                    }
                }
            },
            resetDiv: function (direction) {
                let self = this;
                var div = document.getElementsByClassName("infoBox");
                for (i = 0; i < div.length; i++) {
                    div[i].style.display = "none";
                }
                if (direction === 'p') {
                    if (self.page > 1 && self.uDefPage > 1) {
                        self.page--;
                        self.uDefPage--;
                    }
                } else if (direction === 'n') {
                    if (self.page < self.totalPages && self.uDefPage < self.totalPages) {
                        self.page++;
                        self.uDefPage++;
                    }
                }
            },
            ctrlDiv: function (id) {
                var div = document.getElementById(id);
                var divs = document.getElementsByClassName("infoBox");
                for (i = 0; i < divs.length; i++) {
                    if (divs[i].id != id) {
                        divs[i].style.display = "none";
                    }
                }
                div.style.display = div.style.display === "block" ? "none" : "block";
            },
            removeQuery: function (index) {
                this.queries.splice(index, 1)
                if (this.queries.length == 0) {
                    this.queries.push({query: ""})
                }
            },
            addQuery: function (query) {
                this.queries.push(query)
            },
            getHistory: function () {
                {
                    var self = this;
                    var request = new XMLHttpRequest();
                    request.addEventListener("load", function (ev) {
                        self.history = JSON.parse(ev.target.responseText);
                    });
                    request.open("GET", "/api/history", true);
                    request.send()
                }
            },
            updateText: _.debounce(function () {
                var self = this;
                var request = new XMLHttpRequest();
                var request1 = new XMLHttpRequest();
                request.addEventListener("load", function (ev) {
                    if (ev.currentTarget.status === 200) {
                        self.textQuery = ev.currentTarget.responseText
                    }
                });
                request.open("POST", "/api/cqr2query");
                request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                request.send("query=" + self.cqrQuery + "&lang=" + self.queryLanguage);

                var restriction = {
                    operator: "and",
                    children: [
                        JSON.parse(self.cqrQuery),
                        {
                            query: self.date,
                            fields: ["Publication Date"],
                        }
                    ]
                }
                request1.addEventListener("load", function (ev) {
                    if (ev.currentTarget.status === 200) {
                        self.textQueryDate = ev.currentTarget.responseText
                    }
                });
                request1.open("POST", "/api/cqr2query");
                request1.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                request1.send("query=" + JSON.stringify(restriction) + "&lang=" + self.queryLanguage);
            }, 300),
            clear: function () {
                this.queries = [{query: "", field: "All Fields", operator: "", cqr: {}}, {query: "", field: "All Fields", operator: "and", cqr: {}}];
            },
            resetMeSHBrowser: function () {
                this.meshInfo = [{rank: 0, id:"", name:"", desc:"", yIntroduced:"", supDate:"", terms:[]}];
                this.ids = [];
                this.meshTerm = "";
                this.meshInit = false;
                this.meshReady = false;
                this.meshBusy = false;
                this.page = 1;
			    this.perPage = 5;
                this.totalPages = 0;
                this.userDefPerPage = 5;
                this.uDefPage = 1;
                this.meshSearchStart = 0;
                this.meshSearchEnd = 0;
                this.timeSpend = 0;
            },
            loadResultDocument: function (pmid) {
                let self = this;
                var request = new XMLHttpRequest();
                request.addEventListener("load", function(ev) {
                    if (ev.currentTarget.status === 200) {
                        let resp = ev.currentTarget.responseXML;
                        var strJRes = xml2json(resp);
                        var trimmedJRes = strJRes.replace("undefined", "");
                        var jRes = JSON.parse(trimmedJRes);
                        if (!_.isUndefined(jRes.PubmedArticleSet.PubmedBookArticle)) {
                            var title = null;
                            var abstract = [];
                            var pubdate = null;
                            var book = null;
                            var keywords = [];
                            try {
                                title = jRes.PubmedArticleSet.PubmedBookArticle.BookDocument.ArticleTitle["#text"];
                            } catch (error) {
                                title = null;
                            }
                            var abstractFull = null;
                            try {
                                abstractFull = jRes.PubmedArticleSet.PubmedBookArticle.BookDocument.Abstract["AbstractText"];
                            } catch (error) {
                                abstractFull = null;
                            }
                            if (abstractFull != null) {
                                if (typeof(abstractFull) === "object") {
                                    for (i = 0; i < abstractFull.length; i++) {
                                        var content = abstractFull[i]["#text"];
                                        content = content.replace(/<i>/g, "");
                                        content = content.replace(/<\/i>/g, "");
                                        var field = {
                                            "field" : abstractFull[i]["@Label"],
                                            "content" : content
                                        };
                                        abstract.push(field);
                                    }
                                } else {
                                    var field = {
                                        "field" : "",
                                        "content" : abstractFull,
                                    }
                                    abstract.push(field);
                                }
                            } else {
                                abstract = [];
                            }
                            var pubdateFull = null;
                            try {
                                pubdateFull = jRes.PubmedArticleSet.PubmedBookArticle.PubmedBookData.History.PubMedPubDate;
                            } catch (error) {
                                pubdateFull = null;
                            }
                            if (pubdateFull != null) {
                                for (i = 0; i < pubdateFull.length; i++) {
                                    if (pubdateFull[i]["@PubStatus"] == "pubmed") {
                                        pubdate = pubdateFull[i]["Day"] + "-" + pubdateFull[i]["Month"] + "-" + pubdateFull[i]["Year"];
                                    } else {
                                        pubdate = null;
                                    }
                                }
                            } else {
                                pubdate = null;
                            }
                            try {
                                book = jRes.PubmedArticleSet.PubmedBookArticle.BookDocument.Book.BookTitle["#text"];
                            } catch (error) {
                                book = null;
                            }
                            var keywordsFull = null;
                            try {
                                keywordsFull = jRes.PubmedArticleSet.PubmedBookArticle.BookDocument.KeywordList;
                            } catch (error) {
                                keywordsFull = null;
                            }
                            if (keywordsFull != null) {
                                if (keywordsFull.constructor == Object) {
                                    var k = keywordsFull["Keyword"];
                                    for (i = 0; i < k.length; i++) {
                                        keywords.push(k[i]);
                                    }
                                } else if (Array.isArray(keywordsFull) && keywordsFull.length > 0) {
                                    for (i = 0; i < keywordsFull.length; i++) {
                                        var keywordsArr = keywordsFull[i]["Keyword"];
                                        if (Array.isArray(keywordsArr)) {
                                            for (k = 0; k < keywordsArr.length; k++) {
                                                keywords.push(keywordsArr[k]);
                                            }
                                        } else {
                                            keywords.push(keywordsArr);
                                        }
                                    }
                                } else if (keywordsFull === undefined) {
                                    keywords = [];
                                }
                            } else {
                                keywords = [];
                            }
                            var document = {
                                "type" : "book",
                                "pmid" : pmid,
                                "abstract" : abstract,
                                "title" : title,
                                "book" : book,
                                "pubdate" : pubdate,
                                "keywords" : keywords,
                            };
                            self.document = document;
                            self.showModal = true;
                        } else if (!_.isUndefined(jRes.PubmedArticleSet.PubmedArticle)) {
                            var title = null;
                            var abstract = [];
                            var pubdate = null;
                            var journal = null;
                            var meshheadings = [];
                            var keywords = [];
                            try {
                                title = jRes.PubmedArticleSet.PubmedArticle.MedlineCitation.Article.ArticleTitle;
                            } catch (error) {
                                title = null;
                            }
                            var abstractFull = null;
                            try {
                                abstractFull = jRes.PubmedArticleSet.PubmedArticle.MedlineCitation.Article.Abstract.AbstractText;
                            } catch (error) {
                                abstractFull = null;
                            }
                            if (abstractFull != null) {
                                if (typeof(abstractFull) === "object") {
                                    for (i = 0; i < abstractFull.length; i++) {
                                        var content = abstractFull[i]["#text"];
                                        content = content.replace(/<i>/g, "");
                                        content = content.replace(/<\/i>/g, "");
                                        var field = {
                                            "field" : abstractFull[i]["@Label"],
                                            "content" : content
                                        };
                                        abstract.push(field);
                                    }
                                } else {
                                    var field = {
                                        "field" : "",
                                        "content" : abstractFull,
                                    }
                                    abstract.push(field);
                                }
                            } else {
                                abstract = [];
                            }
                            var pubdateFull = null;
                            try {
                                pubdateFull = jRes.PubmedArticleSet.PubmedArticle.PubmedData.History.PubMedPubDate;
                            } catch (error) {
                                pubdateFull = null;
                            }
                            if (pubdateFull != null) {
                                for (i = 0; i < pubdateFull.length; i++) {
                                    if (pubdateFull[i]["@PubStatus"] == "pubmed") {
                                        pubdate = pubdateFull[i]["Day"] + "-" + pubdateFull[i]["Month"] + "-" + pubdateFull[i]["Year"];
                                    }
                                }
                            } else {
                                pubdate = null;
                            }
                            try {
                                journal = jRes.PubmedArticleSet.PubmedArticle.MedlineCitation.Article.Journal.Title;
                            } catch(error) {
                                journal = null;
                            }
                            var meshheadingsFull = null;
                            var keywordsFull = null;
                            try {
                                meshheadingsFull = jRes.PubmedArticleSet.PubmedArticle.MedlineCitation.MeshHeadingList.MeshHeading;
                            } catch (error) {
                                try {
                                    keywordsFull = jRes.PubmedArticleSet.PubmedArticle.MedlineCitation.KeywordList;
                                } catch (error) {
                                    keywordsFull = null;
                                }
                                meshheadingsFull = null;
                            }
                            if (meshheadingsFull != null) {
                                if (meshheadingsFull.constructor == Object) {
                                    var k = meshheadingsFull["DescriptorName"]["#text"];
                                    meshheadings.push(k);
                                } else if (Array.isArray(meshheadingsFull) && meshheadingsFull.length > 0) {
                                    for (i = 0; i < meshheadingsFull.length; i++) {
                                        var mesh = meshheadingsFull[i]["DescriptorName"]["#text"];
                                        meshheadings.push(mesh);
                                    }
                                } else if (meshheadingsFull === undefined) {
                                    meshheadings = [];
                                }
                            } else if (keywordsFull != null) {
                                if (keywordsFull.constructor == Object) {
                                    var k = keywordsFull["Keyword"];
                                    for (i = 0; i < k.length; i++) {
                                        keywords.push(k[i]["#text"]);
                                    }
                                } else if (Array.isArray(keywordsFull) && keywordsFull.length > 0) {
                                    for (i = 0; i < keywordsFull.length; i++) {
                                        var keywordsArr = keywordsFull[i]["Keyword"];
                                        if (Array.isArray(keywordsArr)) {
                                            for (k = 0; k < keywordsArr.length; k++) {
                                                keywords.push(keywordsArr[k]);
                                            }
                                        } else {
                                            keywords.push(keywordsArr);
                                        }
                                    }
                                } else if (keywordsFull === undefined) {
                                    keywords = [];
                                }
                            } else {
                                keywords = [];
                                meshheadings = [];
                            }
                            var document = {
                                "type" : "article",
                                "pmid" : pmid,
                                "abstract" : abstract,
                                "title" : title,
                                "journal" : journal,
                                "pubdate" : pubdate,
                                "meshheadings" : meshheadings,
                                "keywords" : keywords,
                            };
                            self.document = document;
                            self.showModal = true;
                        }
                    }
                });
                request.open("POST", "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?");
                request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                request.send("db=pubmed&retmode=xml&rettype=medline&id=" + pmid);
            },
            loadSeedDocInfo: function () {
                let self = this;
                let seedDocInfos = [];
                var originalSeed = self.seed;
                var splitedSeed = originalSeed.substring(1, originalSeed.length - 1).split(" ");
                self.seedDocIds = splitedSeed.join(",");
                let request = new XMLHttpRequest();
                request.addEventListener("load", function(ev) {
                    if (ev.currentTarget.status === 200) {
                        let resp = ev.currentTarget.responseXML;
                        var rawValues = resp.querySelectorAll("Item");
                        var tempSeedIds = splitedSeed;
                        for (i = 0; i < rawValues.length; i++) {
                            var seedDocInfo = {};
                            if (rawValues[i].getAttribute("Type") == "String" && rawValues[i].getAttribute("Name") == "Title") {
                                seedDocInfo.title = rawValues[i].innerHTML;
                                seedDocInfo.pmid = tempSeedIds[0];
                                tempSeedIds = tempSeedIds.splice(1);
                                seedDocInfos.push(seedDocInfo);
                            }
                        }
                    }
                    self.seedDocInfos = seedDocInfos;
                });
                request.open("POST", "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?");
                request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                request.send("db=pubmed&id=" + self.seedDocIds);
            },
            loadNextResults: function () {
                let self = this;
                if (!self.busy && !self.finished && self.ready && self.tabState === 'results') {
                    self.busy = true;
                    let request = new XMLHttpRequest();
                    request.addEventListener("load", function (ev) {
                        if (ev.currentTarget.status === 200) {
                            let resp = JSON.parse(ev.currentTarget.responseText);
                            if (resp.Finished) {
                                self.finished = true;
                            }
                            for (let i = 0; i < resp.Documents.length; i++) {
                                self.results.push(resp.Documents[i]);
                            }

                            self.start = self.start + resp.Documents.length;
                            self.busy = false;
                        }
                    });
                    request.open("POST", "/api/scroll");
                    request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                    request.send("start=" + self.start + "&query=" + self.textQueryDate + "&lang=" + self.queryLanguage);
                }
            },
            loadResults: function () {
                let self = this;
                let request1 = new XMLHttpRequest();
                let request = new XMLHttpRequest();
                self.ready = false;
                if (!self.busy) {
                    request1.addEventListener("load", function (ev) {
                        if (ev.currentTarget.status === 200) {
                            self.getHistory();
                        }
                    });
                    request1.open("POST", "/api/history");
                    request1.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                    request1.send("query=" + self.textQuery + "&lang=" + self.queryLanguage + "&date=" + self.date);

                    self.busy = true;
                    request.addEventListener("load", function (ev) {
                        if (ev.currentTarget.status === 200) {
                            let resp = JSON.parse(ev.currentTarget.responseText);
                            self.finished = false;
                            if (resp.Finished) {
                                self.finished = true;
                            }
                            self.busy = false;
                            self.ready = true;
                            self.init = true;
                            self.results = resp.Documents;
                            self.start = resp.Documents.length;
                            self.total = resp.Total;
                            bb.log(ev, "query", self.textQuery)
                        }
                    });
                    request.open("POST", "/api/scroll");
                    request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                    request.send("start=" + 0 + "&query=" + self.textQueryDate + "&lang=" + self.queryLanguage);
                }
            },
            // This action is triggered after the loadMeSH
            loadMeSHTitles: function(ids){
                let self = this;
                let meshInfo = [];
                let names = [];
                let descs = [];
                let yIntroduceds = [];
                let supDates = [];
                let entryTerms = [];
                let request = new XMLHttpRequest();
                request.addEventListener("load", function(ev) {
                    if (ev.currentTarget.status === 200) {
                        var xmlDoc = ev.currentTarget.responseXML;
                        var rawValues = xmlDoc.querySelectorAll("Item");
                        for (i = 0; i < rawValues.length; i++) {
                            if (rawValues[i].getAttribute("Type") == "List" && rawValues[i].getAttribute("Name") == "DS_MeshTerms") {
                                names.push(rawValues[i].childNodes[1].innerHTML);
                                var terms = [];
                                for (k = 2; k < rawValues[i].childNodes.length; k++) {
                                    if (rawValues[i].childNodes[k].innerHTML != undefined) {
                                        terms.push(rawValues[i].childNodes[k].innerHTML);
                                    }
                                }
                                entryTerms.push(terms);
                            } else if (rawValues[i].getAttribute("Type") == "String" && rawValues[i].getAttribute("Name") == "DS_ScopeNote") {
                                descs.push(rawValues[i].innerHTML);
                            } else if (rawValues[i].getAttribute("Type") == "Date" && rawValues[i].getAttribute("Name") == "DS_EntryDate") {
                                var tempStr = rawValues[i].innerHTML.toString()
                                var splitStr = tempStr.split(" ")[0];
                                supDates.push(splitStr);
                            } else if (rawValues[i].getAttribute("Type") == "String" && rawValues[i].getAttribute("Name") == "DS_YearIntroduced") {
                                yIntroduceds.push(rawValues[i].innerHTML);
                            }
                        }
                        for (j = 0; j < ids.length; j++) {
                            var temp = {
                                rank: j + 1,
                                id: ids[j],
                                name: names[j],
                                yIntroduced: yIntroduceds[j],
                                desc: descs[j],
                                supDate: supDates[j],
                                terms: entryTerms[j]
                            };
                            meshInfo.push(temp);
                        }
                        self.meshInfo = meshInfo;
                    }
                    self.meshInit = true;
                    self.meshReady = true;
                    self.meshBusy = false;
                    self.meshSearchEnd = new Date().getTime();
                    self.timeSpend = (self.meshSearchEnd - self.meshSearchStart)/1000;
                });
                request.open("POST", "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?");
                request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                request.send("db=mesh&sort=relevance" + "&id=" + self.ids.toString());
            },
            // load MeSH IDs and save for later processing then load MeSH Term information by calling loadMeSHTitles
            loadMeSH: function (e) {
                if ((e != undefined && e.keyCode === 13) || e === undefined) {
                    let self = this;
                    let request = new XMLHttpRequest();
                    self.meshBusy = true;
                    self.meshReady = false;
                    self.ids = [];
                    self.meshInfo = [{rank: 0, id:"", name:"", desc:"", yIntroduced:"", supDate:"", terms:[]}];
                    self.page = 1;
                    self.uDefPage = 1;
                    self.totalPages = 0;
                    self.meshInit = false;
                    self.meshSearchStart = new Date().getTime();
                    request.addEventListener("load", function(ev) {
                        let ids = [];
                        if (ev.currentTarget.status === 200) {
                            var xmlDoc = ev.currentTarget.responseXML;
                            let rawValues = xmlDoc.getElementsByTagName("Id");
                            for (i = 0; i < rawValues.length; i++) {
                                ids[i] = rawValues[i].childNodes[0].nodeValue;
                            }
                        } else {
                            ids = [0];
                            self.meshInit = false;
                        }
                        self.ids = ids;
                        self.loadMeSHTitles(ids);
                    });
                    request.open("POST", "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?");
                    request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                    // Set retmax to 9999999 simply to avoid another unneccessary API call to get the correct count
                    request.send("db=mesh" + "&sort=relevance&term=" + self.meshTerm + "&retmax=9999999");
                }
            },
            changeNumOfTermsPerPage: function (e) {
                if ((e != undefined && e.keyCode === 13) || e === undefined) {
                    let self = this;
                    if (/^\d+$/.test(self.userDefPerPage)) {
                        if (self.userDefPerPage === '' || parseInt(self.userDefPerPage) === 0 || parseInt(self.userDefPerPage) < 0) {
                            self.perPage = 10;
                        } else {
                            self.perPage = parseInt(self.userDefPerPage);
                        }
                    } else {
                        self.perPage = 10;
                    }
                    self.page = 1;
                    self.uDefPage = 1;
                }
            },
            // Create pagination
            paginate: function (meshInfo) {
                let self = this;
                let page = self.page;
                self.totalPages = Math.ceil(meshInfo.length/self.perPage);
                let perPage = self.perPage;
                let from = (page * perPage) - perPage;
                let to = (page * perPage);
                return  meshInfo.slice(from, to);
		    },
        },
        beforeMount: function () {
            this.getHistory();
            this.loadSeedDocInfo();
        },
        watch: {
            // Do not continue to update the log when we are not in the console tab.
            cqrQuery: function () {
                this.updateText()
            },
            // tabState: function () {
            //     if (this.tabState === "results") {
            //         this.loadNextResults();
            //     }
            // }
        }
    })
</script>
</body>
</html>